---
id: interview-performance

title: Interview Performance
---

# 页面加载性能

- [web.dev](https://web.dev/)

指标：

- 最大内容绘制（Largest Contentful Paint，LCP）
- 首次输入延迟（First Input Delay，FID）

性能分析：

- Chrome DevTools Performance 面板
- Vue 浏览器插件

## 关键渲染路径

- DOM。通过 HTML 构建文档对象模型。
- CSSOM。通过 CSS 构建 CSS 对象模型。
- JavaScript。执行 JavaScript 代码（可能会修改 DOM 和 CSSOM）。
- 渲染树。通过 DOM 和 CSSOM 构建渲染树。
- 布局。计算渲染树中每个元素的尺寸和位置。
- 绘制。在内存中分层绘制元素的像素。
- 合成。将绘制的多个图层合成最终的屏幕图像。合成步骤可以利用 GPU 进行加速。

## 关键渲染路径上的资源

浏览器需要等待一些关键资源下载完成，然后才能完成初始渲染。包括：

- HTML 的一部分。
- `<head>` 中阻塞渲染的 CSS。
- `<head>` 中阻塞渲染的 JavaScript。

浏览器以流式方式处理 HTML，一旦获取网页 HTML 的任何部分，就会开始对其进行处理。然后浏览器可以先呈现网页，然后再处理其余部分的 HTML。

在首次渲染时，浏览器通常不会等待：

- 整个 HTML。
- 字体。
- 图片。
- `<head>` 元素外的非阻塞渲染的 JavaScript。例如，位于 `<body>` 末尾的 `<script>` 元素。
- `<head>` 元素外或 media 属性不适用于当前视口的 CSS，不会阻塞渲染。

## 性能指标

## 性能优化

### 渲染方案

- SPA（Single Page Application）
- SSR（Server Side Rendering）
- SSG（Static Site Generation）

### Tree-Shaking

- 采用构建步骤。
  - 当使用了构建步骤时，模板会被预编译，因此我们无须在浏览器中载入 Vue 编译器。这在同样最小化加上 gzip 优化下会相对缩小 14kb 并避免运行时的编译开销。
  - 如果使用的是相对现代的打包工具，许多 Vue 的 API 都是可以被 tree-shake 的。
- 尽量选择提供 ES 模块格式的依赖，对于 Tree-Shaking 更友好。例如，选择 `lodash-es` 比 `lodash` 更好。

### 代码分割

代码分割是指构建工具将构建后的 JavaScript 包拆分为多个较小的，可以按需或并行加载的文件。通过适当的代码分割，页面加载时需要的功能可以立即下载，而额外的文件只在需要时才加载，从而提高性能。

# 运行时优化

## 案例

### GPS 上报

- 通过 WebSocket 接收 GPS 点位上报消息。GPS 点位多，上报频率高，每次上报以后触发地图点位更新动画，导致卡顿。
- 缓存及批量处理。将一段时间内的上报消息缓存，定时批量处理。

### 地图优化

- 地图引擎相关对象被 Vue 转换为响应式对象，由于地图引擎对象属性较多，并且如图层对象可能包含大量点位数据，转换为响应式对象会导致不必要的依赖收集和派发更新过程，影响性能。提供统一的封装，在创建地图相关对象时为对象设置 `_isVue`（Vue 2.6）或 `__v_skip`（Vue 2.7）属性，避免被转换为响应式对象。
- 共享样式。地图上每个点位都要创建一个样式对象，当地图上点位数量较多时，会导致内存占用过高，同时也会影响渲染性能。通过对点位属性 Hash 的方式，利用函数缓存避免重复创建相同的样式对象，使相同样式的点位共享一个样式对象。同时在创建样式对象的过程中，对图片资源请求、SVG 编码等耗时操作进行缓存，避免重复操作。
- 点位事件绑定优化。地图引擎只提供了单个点位点击事件的监听方法。实际应用中，当点位数量较多时，每个点位都绑定点击事件会导致内存占用过高；并且点位移除以后，事件监听回调函数持有的闭包可能还包含了对已经移除的点位对象的引用，导致内存泄漏。统一封装针对图层的点击事件监听，通过类似事件委托的方式，减少事件监听函数的数量，避免内存泄漏。
